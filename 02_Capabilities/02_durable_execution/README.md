# Durable execution

## intro

允许流程在关键节点保存、暂停、从中断回复。在人机交互场景很有用。

这需要

- 1️⃣一个checkpointer来实现持久化
- 2️⃣执行工作流时指定thread标志服
- 3️⃣将任何不确定操作或非幂等的操作（随机数生成、文件写入）封装在`@[task]`里面，确保恢复工作流时，这些操作不会重复执行，而是从持久层检索结果。

## determinism and consistent replay

针对上面的第3点，展开讲讲。

避免重复工作 ：如果一个节点包含多个带有副作用的操作（例如，日志记录、文件写入或网络调用），请将每个操作封装在一个单独的任务中。这样可以确保在工作流恢复时，操作不会重复执行，并且其结果可以从持久层检索。

封装非确定性操作： 将任何可能产生非确定性结果的代码（例如，随机数生成）封装在任务或节点中。这样可以确保在恢复运行时，工作流能够严格按照记录的步骤顺序执行，并获得相同的结果。

使用幂等操作 ：尽可能确保副作用（例如 API 调用、文件写入）是幂等的。这意味着，如果工作流中某个操作失败后重试，其效果将与首次执行时相同。这一点对于导致数据写入的操作尤为重要。如果某个任务启动但未能成功完成，工作流恢复后将重新运行该任务 ，并依赖已记录的结果来保持一致性。使用幂等键或验证现有结果，以避免意外重复，从而确保工作流执行流畅且可预测。

## Durability modes

三种持久化模式（平衡性能和数据一致性）

持久化程度从低到高："exit", "async", "sync"

- "exit": 执行完成时才持久化（中间状态不保存）
- "async": 异步持久化，会在下一步执行*期间*持久化。执行过程中崩溃可能无法写入
- "sync": 同步持久化，所有更改都会在下一步*开始之前*持久化，确保每个检查点在继续执行前都被写入。

调用前可以指定模式：

```python
graph.stream(
    {"input": "test"},
    durability="sync"
)
```

## Using tasks in nodes

节点包含多个操作，把每个操作转化为一个任务，比将操作重构为单独的节点更好。

比如[task示例](tasks.ipynb)中，单个url请求可以不用task，但是如果一个节点中包含多个url请求，就用task封装单个请求，这样恢复时，已经运行的task会从持久层获取结果，而不会重复执行。

## Resuming Workflows

暂停恢复工作流。interrupt函数暂停，Command恢复并更新状态。

故障恢复，从特定checkpoint恢复

## Starting Points for Resumming Workflows

恢复工作流的起点？

用StateGraph是执行停止的节点开头。

节点内部进行子图调用，是已停止子图的父节点。子图内部是执行停止的具体节点。

函数式api，则起始点是entrypoint。